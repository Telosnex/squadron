<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../jgenhtml.xsl"?><coverage branch-rate="NaN" branches-covered="0" branches-valid="0" complexity="0" date="2024-09-07" filename="worker_pool.dart" function-rate="NaN" functions-covered="0" functions-valid="0" line-rate="0.89784944" lines-covered="167" lines-valid="186" package="/pool" testname="lcov.info" version="1.5">
    <lines>
        <line>
            <code>import 'dart:async';</code>
        </line>
        <line>
            <code>import 'dart:collection';</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>import 'package:logger/logger.dart';</code>
        </line>
        <line>
            <code>import 'package:using/using.dart';</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>import '../concurrency_settings.dart';</code>
        </line>
        <line>
            <code>import '../exceptions/exception_manager.dart';</code>
        </line>
        <line>
            <code>import '../exceptions/squadron_error.dart';</code>
        </line>
        <line>
            <code>import '../exceptions/squadron_exception.dart';</code>
        </line>
        <line>
            <code>import '../exceptions/worker_exception.dart';</code>
        </line>
        <line>
            <code>import '../iworker.dart';</code>
        </line>
        <line>
            <code>import '../stats/perf_counter.dart';</code>
        </line>
        <line>
            <code>import '../stats/worker_stat.dart';</code>
        </line>
        <line>
            <code>import '../worker/worker.dart';</code>
        </line>
        <line>
            <code>import '../worker_service.dart';</code>
        </line>
        <line>
            <code>import '_pool_worker.dart';</code>
        </line>
        <line>
            <code>import '_worker_stream_task.dart';</code>
        </line>
        <line>
            <code>import '_worker_task.dart';</code>
        </line>
        <line>
            <code>import '_worker_value_task.dart';</code>
        </line>
        <line>
            <code>import 'stream_task.dart';</code>
        </line>
        <line>
            <code>import 'task.dart';</code>
        </line>
        <line>
            <code>import 'value_task.dart';</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>typedef WorkerFactory&lt;W&gt; = W Function();</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>/// Worker pool responsible for instantiating, starting and stopping workers running in parallel.</code>
        </line>
        <line>
            <code>/// A [WorkerPool] is also responsible for creating and assigning [WorkerTask]s to [Worker]s.</code>
        </line>
        <line>
            <code>class WorkerPool&lt;W extends Worker&gt;</code>
        </line>
        <line>
            <code>    with Releasable</code>
        </line>
        <line>
            <code>    implements WorkerService, IWorker {</code>
        </line>
        <line>
            <code>  /// Create a worker pool.</code>
        </line>
        <line>
            <code>  ///</code>
        </line>
        <line>
            <code>  /// Workers are instantiated using the provided [_workerFactory].</code>
        </line>
        <line>
            <code>  /// The pool will only instantiate workers as needed, depending on [concurrencySettings].</code>
        </line>
        <line>
            <code>  /// The [ConcurrencySettings.minWorkers] and [ConcurrencySettings.maxWorkers] settings control</code>
        </line>
        <line>
            <code>  /// how many workers will live in the pool. The [ConcurrencySettings.maxParallel] setting</code>
        </line>
        <line>
            <code>  /// controls how many tasks can be posted to each individual worker in the pool.</code>
        </line>
        <line hits="4">
            <code>  WorkerPool(this._workerFactory,</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      {ConcurrencySettings? concurrencySettings,</code>
        </line>
        <line>
            <code>      ExceptionManager? exceptionManager})</code>
        </line>
        <line hits="0">
            <code>      : concurrencySettings = concurrencySettings ?? ConcurrencySettings(),</code>
        </line>
        <line hits="8">
            <code>        _exceptionManager = exceptionManager ?? ExceptionManager();</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="3">
            <code>  @override</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>  void release() {</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="6">
            <code>    stop();</code>
            <hit count="6" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="6">
            <code>    super.release();</code>
            <hit count="6" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>  }</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  final WorkerFactory&lt;W&gt; _workerFactory;</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  @override</code>
        </line>
        <line>
            <code>  Logger? channelLogger;</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="4">
            <code>  @override</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>  ExceptionManager get exceptionManager =&gt;</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>      (_exceptionManager ??= ExceptionManager());</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>  ExceptionManager? _exceptionManager;</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Concurrency settings.</code>
        </line>
        <line>
            <code>  final ConcurrencySettings concurrencySettings;</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Minimum workers.</code>
        </line>
        <line hits="16">
            <code>  int get minWorkers =&gt; concurrencySettings.minWorkers;</code>
            <hit count="16" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Maximum workers.</code>
        </line>
        <line hits="16">
            <code>  int get maxWorkers =&gt; concurrencySettings.maxWorkers;</code>
            <hit count="16" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Maximum tasks per worker.</code>
        </line>
        <line hits="15">
            <code>  int get maxParallel =&gt; concurrencySettings.maxParallel;</code>
            <hit count="15" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Maximum running tasks.</code>
        </line>
        <line hits="12">
            <code>  int get maxConcurrency =&gt; concurrencySettings.maxConcurrency;</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="4">
            <code>  final _workers = &lt;PoolWorker&lt;W&gt;&gt;[];</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="4">
            <code>  final _deadWorkerStats = &lt;WorkerStat&gt;[];</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Whether this pool is scheduled for stopping.</code>
        </line>
        <line hits="3">
            <code>  bool get stopped =&gt; _stopped;</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>  bool _stopped = false;</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Number of workers.</code>
        </line>
        <line hits="4">
            <code>  int get size =&gt; _workers.length;</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Maximum number of workers.</code>
        </line>
        <line hits="0">
            <code>  int get maxSize =&gt; _maxSize;</code>
        </line>
        <line>
            <code>  int _maxSize = 0;</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Current workload.</code>
        </line>
        <line hits="0">
            <code>  int get workload =&gt; stats.fold&lt;int&gt;(0, (p, w) =&gt; p + w.workload);</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Maximum workload.</code>
        </line>
        <line hits="4">
            <code>  int get maxWorkload =&gt; fullStats.fold&lt;int&gt;(</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="5">
            <code>      0, (p, s) =&gt; (p &gt;= s.maxWorkload) ? p : s.maxWorkload);</code>
            <hit count="5" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Total workload.</code>
        </line>
        <line hits="0">
            <code>  int get totalWorkload =&gt;</code>
        </line>
        <line hits="0">
            <code>      fullStats.fold&lt;int&gt;(0, (p, s) =&gt; p + s.totalWorkload);</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Number of errors.</code>
        </line>
        <line hits="0">
            <code>  int get totalErrors =&gt; fullStats.fold&lt;int&gt;(0, (p, s) =&gt; p + s.totalErrors);</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  final _workerPoolListeners =</code>
        </line>
        <line hits="4">
            <code>      &lt;Object, void Function(W worker, bool removed)&gt;{};</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Registers a callback to be invoked when a worker thread is added or removed from the pool.</code>
        </line>
        <line hits="0">
            <code>  Object registerWorkerPoolListener(</code>
        </line>
        <line>
            <code>      void Function(W worker, bool removed) listener) {</code>
        </line>
        <line hits="0">
            <code>    final token = Object();</code>
        </line>
        <line hits="0">
            <code>    _workerPoolListeners[token] = listener;</code>
        </line>
        <line>
            <code>    return token;</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Unregisters a callback.</code>
        </line>
        <line hits="0">
            <code>  void unregisterWorkerPoolListener(</code>
        </line>
        <line>
            <code>      {Function(W worker, bool removed)? listener, Object? token}) {</code>
        </line>
        <line>
            <code>    if (token != null) {</code>
        </line>
        <line hits="0">
            <code>      _workerPoolListeners.remove(token);</code>
        </line>
        <line>
            <code>    } else if (listener != null) {</code>
        </line>
        <line hits="0">
            <code>      _workerPoolListeners.removeWhere((key, value) =&gt; value == listener);</code>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  int _startingWorkers = 0;</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="8">
            <code>  int _getProvisionNeeds(int workload) {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>    if (workload &lt; minWorkers) {</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      // at least minWorkers</code>
        </line>
        <line hits="4">
            <code>      workload = minWorkers;</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="20">
            <code>    if (maxWorkers &gt; 0 &amp;&amp; workload &gt; maxWorkers) {</code>
            <hit count="20" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      // at most maxWorkers if &gt; 0</code>
        </line>
        <line hits="3">
            <code>      workload = maxWorkers;</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>    // adjust by _workers.length and _startingWorkers</code>
        </line>
        <line hits="24">
            <code>    return workload - _workers.length - _startingWorkers;</code>
            <hit count="24" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>  }</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="8">
            <code>  Future&lt;void&gt; _provisionWorkers(int workload) {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>    final tasks = &lt;Future&gt;[];</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>    final errors = [];</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>    for (var i = 0; i &lt; workload; i++) {</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="0">
            <code>      try {</code>
        </line>
        <line hits="12">
            <code>        final worker = _workerFactory();</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>        worker.channelLogger = channelLogger;</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>        worker.setExceptionManager(exceptionManager);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="12">
            <code>        final poolWorker = PoolWorker(worker, maxParallel);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>        _startingWorkers++;</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="24">
            <code>        tasks.add(poolWorker.worker.start().whenComplete(() {</code>
            <hit count="24" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>          _startingWorkers--;</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>        }).then((_) {</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>          // start succeeded: register worker</code>
        </line>
        <line hits="8">
            <code>          _addWorkerAndNotify(poolWorker);</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="9">
            <code>        }).catchError((ex, st) {</code>
            <hit count="9" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>          // start failed, ensure the worker is stopped</code>
        </line>
        <line hits="3">
            <code>          poolWorker.worker.stop();</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>          errors.add(SquadronException.from(ex, st));</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>        }));</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="0">
            <code>      } catch (ex, st) {</code>
        </line>
        <line hits="0">
            <code>        errors.add(SquadronException.from(ex, st));</code>
        </line>
        <line>
            <code>      }</code>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="16">
            <code>    return Future.wait(tasks).whenComplete(() {</code>
            <hit count="16" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="20">
            <code>      if (_workers.length &gt; _maxSize) {</code>
            <hit count="20" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="16">
            <code>        _maxSize = _workers.length;</code>
            <hit count="16" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      }</code>
        </line>
        <line hits="8">
            <code>      if (errors.isNotEmpty) {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>        if (errors.length &lt; tasks.length) {</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>          // some tasks failed: warn</code>
        </line>
        <line hits="0">
            <code>          channelLogger?.e(() =&gt; 'Error while provisionning workers: $errors');</code>
        </line>
        <line>
            <code>        } else {</code>
        </line>
        <line>
            <code>          // all tasks failed: throw</code>
        </line>
        <line hits="7">
            <code>          throw errors.firstWhere((e) =&gt; e is SquadronError,</code>
            <hit count="7" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>                  orElse: () =&gt; null) ??</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>              errors.firstWhere((e) =&gt; e is WorkerException,</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>                  orElse: () =&gt; null) ??</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>              errors.first;</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>        }</code>
        </line>
        <line>
            <code>      }</code>
        </line>
        <line hits="4">
            <code>    });</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>  }</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Ensure at least [ConcurrencySettings.minWorkers] workers are started</code>
        </line>
        <line>
            <code>  /// (defaulting to 1 if [ConcurrencySettings.minWorkers] is zero).</code>
        </line>
        <line hits="3">
            <code>  @override</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>  FutureOr&lt;void&gt; start() {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="6">
            <code>    _stopped = false;</code>
            <hit count="6" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>    final needs = _getProvisionNeeds(_queue.isEmpty ? 1 : _queue.length);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>    if (needs &gt; 0) {</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="6">
            <code>      return _provisionWorkers(needs);</code>
            <hit count="6" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="1">
            <code>  }</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="8">
            <code>  void _notify(W worker, {required bool removed}) {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>    for (var listener in _workerPoolListeners.values) {</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      try {</code>
        </line>
        <line hits="0">
            <code>        listener(worker, removed);</code>
        </line>
        <line>
            <code>      } catch (ex) {</code>
        </line>
        <line>
            <code>        // swallow error from user land</code>
        </line>
        <line>
            <code>      }</code>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="4">
            <code>  }</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="8">
            <code>  void _removeWorkerAndNotify(PoolWorker&lt;W&gt; poolWorker) {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>    _workers.remove(poolWorker);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>    _notify(poolWorker.worker, removed: true);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>  }</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="4">
            <code>  void _addWorkerAndNotify(PoolWorker&lt;W&gt; poolWorker) {</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>    _workers.add(poolWorker);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>    _notify(poolWorker.worker, removed: false);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="8">
            <code>  int _removeWorker(PoolWorker&lt;W&gt; poolWorker, bool force) {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="9">
            <code>    if (force || _workers.length &gt; concurrencySettings.minWorkers) {</code>
            <hit count="9" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>      final worker = poolWorker.worker;</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>      worker.stop();</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="16">
            <code>      _deadWorkerStats.add(worker.stats);</code>
            <hit count="16" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>      _removeWorkerAndNotify(poolWorker);</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>      return 1;</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    } else {</code>
        </line>
        <line hits="1">
            <code>      return 0;</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="4">
            <code>  }</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Stop idle pool workers matching the [predicate].</code>
        </line>
        <line>
            <code>  /// If [predicate] is null or not provided, all workers will be stopped.</code>
        </line>
        <line>
            <code>  /// Stopping a worker does not interrupt or cancel processing. Workers will</code>
        </line>
        <line>
            <code>  /// complete pending tasks before shutting down. In the meantime, they will</code>
        </line>
        <line>
            <code>  /// not receive any new workload.</code>
        </line>
        <line>
            <code>  /// Returns the number of workers that have been stopped.</code>
        </line>
        <line hits="4">
            <code>  @override</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>  int stop([bool Function(W worker)? predicate]) {</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    List&lt;PoolWorker&lt;W&gt;&gt; targets;</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    bool force = (predicate == null);</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    if (force) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      // kill workers while keeping enough workers alive to process pending tasks</code>
        </line>
        <line hits="24">
            <code>      targets = _workers.skip(_queue.length).toList();</code>
            <hit count="24" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>      _stopped = true;</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    } else {</code>
        </line>
        <line>
            <code>      // kill workers that are idle and satisfy the predicate</code>
        </line>
        <line hits="8">
            <code>      targets = _workers.where((w) =&gt; w.isIdle &amp;&amp; predicate(w.worker)).toList();</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>    var stopped = 0;</code>
        </line>
        <line hits="12">
            <code>    for (var poolWorker in targets) {</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>      stopped += _removeWorker(poolWorker, force);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="4">
            <code>    return stopped;</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>  }</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="4">
            <code>  final _queue = Queue&lt;WorkerTask&gt;();</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>  final _executing = &lt;WorkerTask&gt;{};</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Gets remaining workload</code>
        </line>
        <line hits="8">
            <code>  int get pendingWorkload =&gt; _queue.length;</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="7">
            <code>  WorkerTask&lt;T, W&gt; _enqueue&lt;T&gt;(WorkerTask&lt;T, W&gt; task) {</code>
            <hit count="7" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>    if (_stopped) {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>      throw SquadronErrorExt.create(</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>        'The pool cannot accept new requests because it is stopped',</code>
        </line>
        <line>
            <code>      );</code>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="12">
            <code>    _queue.addLast(task);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>    _schedule();</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>    return task;</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>  }</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Registers and schedules a [task] that returns a single value.</code>
        </line>
        <line>
            <code>  /// Returns a future that completes with the task's value.</code>
        </line>
        <line hits="5">
            <code>  Future&lt;T&gt; execute&lt;T&gt;(Future&lt;T&gt; Function(W worker) task,</code>
            <hit count="5" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>          {PerfCounter? counter}) =&gt;</code>
        </line>
        <line hits="9">
            <code>      scheduleValueTask(task, counter: counter).value;</code>
            <hit count="9" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Registers and schedules a [task] that returns a stream of values.</code>
        </line>
        <line>
            <code>  /// Returns a stream containing the task's values.</code>
        </line>
        <line hits="6">
            <code>  Stream&lt;T&gt; stream&lt;T&gt;(Stream&lt;T&gt; Function(W worker) task,</code>
            <hit count="6" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>          {PerfCounter? counter}) =&gt;</code>
        </line>
        <line hits="12">
            <code>      scheduleStreamTask(task, counter: counter).stream;</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Registers and schedules a [task] that returns a single value.</code>
        </line>
        <line>
            <code>  /// Returns a [ValueTask]&lt;T&gt;.</code>
        </line>
        <line hits="4">
            <code>  ValueTask&lt;T&gt; scheduleValueTask&lt;T&gt;(Future&lt;T&gt; Function(W worker) task,</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>          {PerfCounter? counter}) =&gt;</code>
        </line>
        <line hits="9">
            <code>      _enqueue&lt;T&gt;(WorkerValueTask&lt;T, W&gt;(task, counter)) as ValueTask&lt;T&gt;;</code>
            <hit count="9" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Registers and schedules a [task] that returns a stream of values.</code>
        </line>
        <line>
            <code>  /// Returns a [StreamTask]&lt;T&gt;.</code>
        </line>
        <line hits="6">
            <code>  StreamTask&lt;T&gt; scheduleStreamTask&lt;T&gt;(Stream&lt;T&gt; Function(W worker) task,</code>
            <hit count="6" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>          {PerfCounter? counter}) =&gt;</code>
        </line>
        <line hits="12">
            <code>      _enqueue&lt;T&gt;(WorkerStreamTask&lt;T, W&gt;(task, counter)) as StreamTask&lt;T&gt;;</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Schedule tasks.</code>
        </line>
        <line hits="8">
            <code>  void _schedule() {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="16">
            <code>    if (_workers.isEmpty &amp;&amp; _startingWorkers &gt; 0) {</code>
            <hit count="16" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      // workers are still starting, defer</code>
        </line>
        <line hits="6">
            <code>      Future(_schedule);</code>
            <hit count="6" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>      return;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>    // remove dead workers</code>
        </line>
        <line hits="4">
            <code>    _workers</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>        .where(PoolWorker.isStopped)</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>        .toList() // take a copy</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>        .forEach(_removeWorkerAndNotify);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>    // remove canceled tasks</code>
        </line>
        <line hits="20">
            <code>    _queue.removeWhere((t) =&gt; t.isCanceled);</code>
            <hit count="20" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>    // any work to do?</code>
        </line>
        <line hits="8">
            <code>    if (_queue.isEmpty) {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      // no: effectively stop the pool if needed and return</code>
        </line>
        <line hits="12">
            <code>      if (_stopped &amp;&amp; _executing.isEmpty) {</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>        stop();</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      }</code>
        </line>
        <line hits="4">
            <code>      return;</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>    // yes: dispatch tasks to workers</code>
        </line>
        <line hits="8">
            <code>    _dispatchTasks();</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>    // and provision more workers if possible and necessary</code>
        </line>
        <line hits="16">
            <code>    final needs = _getProvisionNeeds(_queue.length);</code>
            <hit count="16" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>    if (needs &gt; 0) {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="6">
            <code>      _provisionWorkers(needs).then(</code>
            <hit count="6" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>        (_) =&gt; _dispatchTasks(),</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>        onError: (ex) {</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>          channelLogger?.e(() =&gt; 'Provisionning workers failed with error $ex');</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>          while (_queue.isNotEmpty) {</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>            _queue.removeFirst().cancel('Provisionning workers failed');</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>          }</code>
        </line>
        <line hits="1">
            <code>        },</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      );</code>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="4">
            <code>  }</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="4">
            <code>  int _sortAndGetMaxCapacity() {</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>    _workers.sort(PoolWorker.compareCapacityDesc);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="24">
            <code>    return _workers.isEmpty ? 0 : _workers.first.capacity;</code>
            <hit count="24" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="8">
            <code>  void _dispatchTasks() {</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    int maxCapacity;</code>
        </line>
        <line hits="20">
            <code>    while (_queue.isNotEmpty &amp;&amp; (maxCapacity = _sortAndGetMaxCapacity()) &gt; 0) {</code>
            <hit count="20" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>      maxCapacity -= 1;</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="20">
            <code>      for (var idx = 0; idx &lt; _workers.length; idx++) {</code>
            <hit count="20" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>        final w = _workers[idx];</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="28">
            <code>        if (_queue.isEmpty || w.capacity == 0 || w.capacity &lt; maxCapacity) {</code>
            <hit count="28" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>          break;</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>        }</code>
        </line>
        <line hits="12">
            <code>        final task = _queue.removeFirst();</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>        _executing.add(task);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="16">
            <code>        w.run(task).whenComplete(() {</code>
            <hit count="16" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="12">
            <code>          _executing.remove(task);</code>
            <hit count="12" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="8">
            <code>          _schedule();</code>
            <hit count="8" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>        });</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      }</code>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="4">
            <code>  }</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Task cancelation. If a specific [task] is provided, only this task will be canceled.</code>
        </line>
        <line>
            <code>  /// Otherwise, all tasks registered with the [WorkerPool] are canceled.</code>
        </line>
        <line hits="2">
            <code>  void cancel([Task? task, String? message]) {</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    if (task != null) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>      _executing.remove(task);</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="5">
            <code>      _queue.removeWhere((t) =&gt; t == task);</code>
            <hit count="5" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>      task.cancel(message);</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    } else {</code>
        </line>
        <line hits="4">
            <code>      final toBeCanceled = _executing.followedBy(_queue).toList();</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>      _executing.clear();</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>      _queue.clear();</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>      for (var task in toBeCanceled) {</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>        task.cancel(message);</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      }</code>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="1">
            <code>  }</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Worker statistics.</code>
        </line>
        <line hits="4">
            <code>  Iterable&lt;WorkerStat&gt; get stats =&gt; _workers.map(PoolWorker.getStats);</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Full worker statistics.</code>
        </line>
        <line hits="5">
            <code>  Iterable&lt;WorkerStat&gt; get fullStats =&gt; _deadWorkerStats.followedBy(stats);</code>
            <hit count="5" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Worker pools do not need an [operations] map.</code>
        </line>
        <line hits="0">
            <code>  @override</code>
        </line>
        <line hits="0">
            <code>  Map&lt;int, CommandHandler&gt; get operations =&gt; WorkerService.noOperations;</code>
        </line>
        <line>
            <code>}</code>
        </line>
    </lines>
    <config branch-coverage="true" description-file="false" function-coverage="true" genhtml_hi_limit="90" genhtml_med_limit="75" legend="false" no-sort="false" no-source="false"/>
    <base href="../"/>
    <base href="../"/>
</coverage>
