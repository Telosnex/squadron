<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../jgenhtml.xsl"?><coverage branch-rate="NaN" branches-covered="0" branches-valid="0" complexity="0" date="2022-04-09" filename="_worker_monitor.dart" function-rate="NaN" functions-covered="0" functions-valid="0" line-rate="1.0" lines-covered="34" lines-valid="34" package="/src" testname="lcov.info" version="1.5">
    <lines>
        <line>
            <code>import 'cancellation_token.dart';</code>
        </line>
        <line>
            <code>import 'worker_exception.dart';</code>
        </line>
        <line>
            <code>import 'worker_pool.dart';</code>
        </line>
        <line>
            <code>import 'worker_request.dart';</code>
        </line>
        <line>
            <code>import 'worker_service.dart';</code>
        </line>
        <line>
            <code>import 'worker_task.dart';</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>/// Cancellation token reference. This special cancellation token is managed by the [WorkerMonitor] and is used to</code>
        </line>
        <line>
            <code>/// mirror' cancellation tokens presented to Squadron by callers of a worker service. When a [WorkerRequest] is</code>
        </line>
        <line>
            <code>/// handled by the platform worker and that request is associated with a cancellation request, the [WorkerMonitor]</code>
        </line>
        <line>
            <code>/// will override the request's cancellation token with a [_CancellationTokenReference]. The same cancellation may</code>
        </line>
        <line>
            <code>/// be used for several service calls, so the [WorkerMonitor] keeps a map of [_CancellationTokenReference] and a</code>
        </line>
        <line>
            <code>/// reference count that is incremented for each [WorkerRequest] having the same cancellation token and decremented</code>
        </line>
        <line>
            <code>/// when processing is finished. When the reference count drops to 0 and the cancellation token was not cancelled,</code>
        </line>
        <line>
            <code>/// the [_CancellationTokenReference] is removed from the map.</code>
        </line>
        <line>
            <code>///</code>
        </line>
        <line>
            <code>/// When a caller cancels a token, a cancellation notification is sent to all workers in the pool and the</code>
        </line>
        <line>
            <code>/// corresponding [_CancellationTokenReference] will be cancelled. Services executing in the context of a platform</code>
        </line>
        <line>
            <code>/// worker will be able to inspect the token's status to interrupt processing gracefully. If the token's status is</code>
        </line>
        <line>
            <code>/// not inspected, processing will continue in platform workers, but will be interrupted on caller-side with a</code>
        </line>
        <line>
            <code>/// [CancelledException].</code>
        </line>
        <line>
            <code>class _CancellationTokenReference extends CancellationToken {</code>
        </line>
        <line hits="2">
            <code>  _CancellationTokenReference._noToken()</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      : hasRef = false,</code>
        </line>
        <line hits="1">
            <code>        super(0);</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  _CancellationTokenReference(CancellationToken token)</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      : hasRef = true,</code>
        </line>
        <line hits="3">
            <code>        super(token.id, token.message);</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  final bool hasRef;</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  int refCount = 0;</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  @override</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>  CancelledException? get exception =&gt; _exception;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>  CancelledException? _exception;</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  void _cancel() {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    if (hasRef) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>      _exception ??= CancelledException(message: message);</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code>}</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>/// Each platform worker will instantiate a [WorkerMonitor] responsible for handling cancellation requests. Worker</code>
        </line>
        <line>
            <code>/// tasks in Squadron may be cancelled in two ways: with a [CancellationToken], giving worker services the chance to</code>
        </line>
        <line>
            <code>/// handle cancellation requests gracefully, or without a [CancellationToken] via [WorkerPool.cancel] or</code>
        </line>
        <line>
            <code>/// [WorkerTask.cancel].</code>
        </line>
        <line>
            <code>class WorkerMonitor {</code>
        </line>
        <line hits="1">
            <code>  WorkerMonitor(this._terminate);</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="4">
            <code>  static final noTokenRef = _CancellationTokenReference._noToken();</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  final SquadronCallback _terminate;</code>
        </line>
        <line>
            <code>  bool _terminationRequested = false;</code>
        </line>
        <line>
            <code>  int _executing = 0;</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  final _cancelTokens = &lt;int, _CancellationTokenReference&gt;{};</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  _CancellationTokenReference _getTokenRef(CancellationToken? token) =&gt;</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      (token == null)</code>
        </line>
        <line hits="1">
            <code>          ? noTokenRef</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>          : _cancelTokens.putIfAbsent(</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>              token.id, () =&gt; _CancellationTokenReference(token));</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  _CancellationTokenReference begin(WorkerRequest request) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>    _executing++;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>    final tokenRef = _getTokenRef(request.cancelToken);</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    if (tokenRef.hasRef) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>      tokenRef.refCount++;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>      request.overrideCancelToken(tokenRef);</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>    return tokenRef;</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="3">
            <code>  void cancel(CancellationToken token) =&gt; _getTokenRef(token)._cancel();</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  void done(_CancellationTokenReference tokenRef) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    if (tokenRef.hasRef) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>      tokenRef.refCount--;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>      if (tokenRef.refCount == 0 &amp;&amp; !tokenRef.cancelled) {</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>        // track only cancelled tokens</code>
        </line>
        <line hits="3">
            <code>        _cancelTokens.remove(tokenRef.id);</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      }</code>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="2">
            <code>    _executing--;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>    if (_terminationRequested &amp;&amp; _executing == 0) {</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>      _terminate();</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  void terminate() {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>    if (_executing == 0) {</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>      _terminate();</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    } else {</code>
        </line>
        <line hits="1">
            <code>      _terminationRequested = true;</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code>}</code>
        </line>
    </lines>
    <config branch-coverage="true" description-file="false" function-coverage="true" genhtml_hi_limit="90" genhtml_med_limit="75" legend="false" no-sort="false" no-source="false"/>
    <base href="../"/>
    <base href="../"/>
</coverage>
