<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../jgenhtml.xsl"?><coverage branch-rate="NaN" branches-covered="0" branches-valid="0" complexity="0" date="2024-02-11" filename="_worker_monitor.dart" function-rate="NaN" functions-covered="0" functions-valid="0" line-rate="0.9574468" lines-covered="45" lines-valid="47" package="/_impl/xplat" testname="lcov.info" version="1.5">
    <lines>
        <line>
            <code>import 'dart:async';</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>import 'package:cancelation_token/cancelation_token.dart';</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>import '../../pool/worker_pool.dart';</code>
        </line>
        <line>
            <code>import '../../tokens/_cancelation_token_ref.dart';</code>
        </line>
        <line>
            <code>import '../../tokens/_squadron_cancelation_token.dart';</code>
        </line>
        <line>
            <code>import '../../worker/worker_request.dart';</code>
        </line>
        <line>
            <code>import '../../worker_service.dart';</code>
        </line>
        <line>
            <code>import '_task.dart';</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>/// Each platform worker will instantiate a [WorkerMonitor] responsible for</code>
        </line>
        <line>
            <code>/// handling cancelation requests. Worker tasks in Squadron may be canceled in</code>
        </line>
        <line>
            <code>/// two ways: with a [CancelationToken], giving worker services the chance to</code>
        </line>
        <line>
            <code>/// handle cancelation requests gracefully, or without a [CancelationToken]</code>
        </line>
        <line>
            <code>/// via [WorkerPool.cancel] or [Task.cancel].</code>
        </line>
        <line>
            <code>class WorkerMonitor {</code>
        </line>
        <line>
            <code>  /// Constructs a new [WorkerMonitor]. The [_terminate] callback will be called</code>
        </line>
        <line>
            <code>  /// by [WorkerMonitor.terminate]. This callback should contain code to</code>
        </line>
        <line>
            <code>  /// shutdown the platform worker and release resources.</code>
        </line>
        <line hits="2">
            <code>  WorkerMonitor(this._terminate);</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  final SquadronCallback _terminate;</code>
        </line>
        <line>
            <code>  bool _terminationRequested = false;</code>
        </line>
        <line>
            <code>  int _executing = 0;</code>
        </line>
        <line>
            <code>  ServiceInstaller? _installer;</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  final _cancelTokens = &lt;String, CancelationTokenReference&gt;{};</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line hits="2">
            <code>  CancelationTokenReference _getTokenRef(SquadronCancelationToken? token) =&gt;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>      (token == null)</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>          ? CancelationTokenReference.noToken</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>          : _cancelTokens.putIfAbsent(</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="5">
            <code>              token.id, () =&gt; CancelationTokenReference(token.id));</code>
            <hit count="5" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Starts monitoring execution of this [request]. If the request contains a cancelation token, it</code>
        </line>
        <line>
            <code>  /// is overridden with a [CancelationTokenReference] and this reference is returned to the sender.</code>
        </line>
        <line>
            <code>  /// Otherwise, returns [CancelationTokenReference.noToken].</code>
        </line>
        <line hits="1">
            <code>  CancelationTokenReference begin(WorkerRequest request) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>    _executing++;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>    final token = _getTokenRef(request.cancelToken);</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    token.usedBy(request);</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    return token;</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  Map&lt;int, SquadronCallback&gt;? _streamCancelers;</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>  int _streamId = 0;</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Assigns a stream ID to the stream canceler callback and registers the callback.</code>
        </line>
        <line hits="1">
            <code>  int registerStreamCanceler(SquadronCallback canceler) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>    final streamId = ++_streamId;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>    (_streamCancelers ??= &lt;int, SquadronCallback&gt;{})[streamId] = canceler;</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    return streamId;</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Unregisters the stream canceled callback associated to the [streamId].</code>
        </line>
        <line hits="1">
            <code>  void unregisterStreamCanceler(int streamId) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>    final canceler = _streamCancelers?[streamId];</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    if (canceler != null) {</code>
        </line>
        <line hits="3">
            <code>      _streamCancelers?.remove(streamId);</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Updates a [token] via the corresponding [CancelationTokenReference].</code>
        </line>
        <line hits="1">
            <code>  void updateToken(SquadronCancelationToken token) =&gt;</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>      _getTokenRef(token).update(token);</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Cancels a stream via the corresponding [streamId].</code>
        </line>
        <line hits="5">
            <code>  void cancelStream(int streamId) =&gt; _streamCancelers?[streamId]?.call();</code>
            <hit count="5" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Stops monitoring execution and releases the [tokenRef].</code>
        </line>
        <line hits="1">
            <code>  void done(CancelationTokenReference tokenRef) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>    tokenRef.release();</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>    if (tokenRef.refCount == 0) {</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>      _cancelTokens.remove(tokenRef.id);</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="2">
            <code>    _executing--;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="4">
            <code>    if (_terminationRequested &amp;&amp; _executing == 0) {</code>
            <hit count="4" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>      _shutdown();</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Installs the service if it implements [ServiceInstaller].</code>
        </line>
        <line hits="1">
            <code>  FutureOr&lt;void&gt; install(WorkerService service) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    if (service is ServiceInstaller) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>      final installer = service as ServiceInstaller;</code>
        </line>
        <line hits="1">
            <code>      _installer = installer;</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>      return installer.install();</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Uninstalls the service if it implements [ServiceInstaller].</code>
        </line>
        <line hits="1">
            <code>  FutureOr&lt;void&gt; _uninstall(ServiceInstaller? installer) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    if (installer != null) {</code>
        </line>
        <line>
            <code>      try {</code>
        </line>
        <line hits="1">
            <code>        var res = installer.uninstall();</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>        if (res is Future&lt;void&gt;) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="3">
            <code>          res = res.onError((error, stackTrace) =&gt; {/* swallow excepions */});</code>
            <hit count="3" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>        }</code>
        </line>
        <line>
            <code>        return res;</code>
        </line>
        <line>
            <code>      } catch (ex) {/* swallow exceptions*/}</code>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="0">
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line>
            <code>  /// Terminates the worker monitored by this instance if there is no pending execution. Otherwise, marks</code>
        </line>
        <line>
            <code>  /// the worker as terminating and termination will be effective when all pending executions are completed.</code>
        </line>
        <line hits="1">
            <code>  void terminate() {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>    if (_executing == 0) {</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>      _shutdown();</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    } else {</code>
        </line>
        <line hits="2">
            <code>      _terminationRequested = true;</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line>
            <code>  }</code>
        </line>
        <line>
            <code/>
        </line>
        <line hits="1">
            <code>  void _shutdown() {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>    final uninstall = _uninstall(_installer);</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="1">
            <code>    if (uninstall is Future) {</code>
            <hit count="1" name="&lt;unnamed&gt;"/>
        </line>
        <line hits="2">
            <code>      uninstall.whenComplete(_terminate);</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    } else {</code>
        </line>
        <line hits="2">
            <code>      _terminate();</code>
            <hit count="2" name="&lt;unnamed&gt;"/>
        </line>
        <line>
            <code>    }</code>
        </line>
        <line hits="0">
            <code>  }</code>
        </line>
        <line>
            <code>}</code>
        </line>
    </lines>
    <config branch-coverage="true" description-file="false" function-coverage="true" genhtml_hi_limit="90" genhtml_med_limit="75" legend="false" no-sort="false" no-source="false"/>
    <base href="../../"/>
    <base href="../../"/>
</coverage>
